import type { ApiPageProps, OperationItem, WebhookItem } from '@/ui/api-page';
import type { ProcessedDocument } from '@/utils/process-document';
import type { TagObject } from '@/types';
import { dump } from 'js-yaml';
import { removeUndefined } from '@/utils/remove-undefined';
import type { OutputEntry } from '@/utils/pages/builder';
import type { InternalOpenAPIMeta } from '@/server/source-api';
import { toStaticData } from '@/utils/pages/to-static-data';

export interface PagesToTextOptions {
  /**
   * Additional imports of your MDX components.
   */
  imports?: {
    names: string[];
    from: string;
  }[];

  /**
   * Customise frontmatter.
   *
   * A `full: true` property will be added by default.
   */
  frontmatter?: (
    title: string,
    description: string | undefined,
    context: DocumentContext,
  ) => Record<string, unknown>;

  /**
   * Add description to document body.
   *
   * We recommend but don't enable it by default because some OpenAPI schemas have invalid description that breaks MDX syntax.
   *
   * @defaultValue false
   */
  includeDescription?: boolean;

  /**
   * Add a comment to the top of generated files indicating they are auto-generated.
   * - `true`: Adds a standardized comment
   * - `false`: No comment is added
   * - `string`: Adds the provided custom comment
   *
   * @defaultValue true
   */
  addGeneratedComment?: boolean | string;
}

export function toText(
  entry: OutputEntry,
  processed: ProcessedDocument,
  options: PagesToTextOptions = {},
) {
  switch (entry.type) {
    case 'operation':
      return generatePage(
        entry.schemaId,
        processed,
        {
          operations: [entry.item],
        },
        {
          ...options,
          ...entry.info,
        },
        {
          type: 'operation',
        },
      );
    case 'group':
      return generatePage(
        entry.schemaId,
        processed,
        {
          operations: entry.operations,
          webhooks: entry.webhooks,
          showTitle: true,
        },
        {
          ...options,
          ...entry.info,
        },
        {
          type: 'file',
        },
      );
    case 'tag':
      return generatePage(
        entry.schemaId,
        processed,
        {
          operations: entry.operations,
          webhooks: entry.webhooks,
          showTitle: true,
        },
        {
          ...options,
          ...entry.info,
        },
        {
          type: 'tag',
          tag: entry.rawTag,
        },
      );
    case 'webhook':
      return generatePage(
        entry.schemaId,
        processed,
        {
          webhooks: [entry.item],
        },
        {
          ...options,
          ...entry.info,
        },
        {
          type: 'operation',
        },
      );
  }
}

export function generateDocument(
  frontmatter: unknown,
  content: string,
  options: PagesToTextOptions,
): string {
  const { addGeneratedComment = true, imports } = options;
  const out: string[] = [];
  const banner = dump(removeUndefined(frontmatter as object)).trimEnd();
  if (banner.length > 0) out.push(`---\n${banner}\n---`);

  if (addGeneratedComment) {
    let commentContent =
      'This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again.';

    if (typeof addGeneratedComment === 'string') {
      commentContent = addGeneratedComment;
    }

    commentContent = commentContent.replaceAll('/', '\\/');
    out.push(`{/* ${commentContent} */}`);
  }

  if (imports) {
    out.push(
      ...imports
        .map((item) => `import { ${item.names.join(', ')} } from ${JSON.stringify(item.from)};`)
        .join('\n'),
    );
  }

  out.push(content);
  return out.join('\n\n');
}

export type DocumentContext =
  | {
      type: 'tag';
      tag: TagObject | undefined;
    }
  | {
      type: 'operation';
    }
  | {
      type: 'file';
    };

function generatePage(
  schemaId: string,
  processed: ProcessedDocument,
  pageProps: Omit<ApiPageProps, 'document'>,
  options: PagesToTextOptions & {
    title: string;
    description?: string;
  },
  context: DocumentContext,
): string {
  const { frontmatter, includeDescription = false } = options;
  const extend = frontmatter?.(options.title, options.description, context);
  const page: ApiPageProps = {
    ...pageProps,
    document: schemaId,
  };

  let meta: InternalOpenAPIMeta | undefined;
  if (page.operations?.length === 1) {
    const operation = page.operations[0];

    meta = {
      method: operation.method.toUpperCase(),
    };
  } else if (page.webhooks?.length === 1) {
    const webhook = page.webhooks[0];

    meta = {
      method: webhook.method.toUpperCase(),
      webhook: true,
    };
  }

  const data = toStaticData(page, processed.dereferenced);
  const content: string[] = [];

  if (options.description && includeDescription) content.push(options.description);
  content.push(pageContent(page));

  return generateDocument(
    {
      title: options.title,
      description: !includeDescription ? options.description : undefined,
      full: true,
      ...extend,
      _openapi: {
        ...meta,
        ...data,
        ...(extend?._openapi as object | undefined),
      },
    },
    content.join('\n\n'),
    options,
  );
}

function pageContent({
  showTitle,
  showDescription,
  document,
  webhooks,
  operations,
}: ApiPageProps): string {
  const propStrs: string[] = [`document={${JSON.stringify(document)}}`];

  // filter extra properties in props
  if (webhooks) {
    propStrs.push(
      `webhooks={${JSON.stringify(
        webhooks.map(
          (item) =>
            ({
              name: item.name,
              method: item.method,
            }) satisfies WebhookItem,
        ),
      )}}`,
    );
  }
  if (operations) {
    propStrs.push(
      `operations={${JSON.stringify(
        operations.map(
          (item) =>
            ({
              path: item.path,
              method: item.method,
            }) satisfies OperationItem,
        ),
      )}}`,
    );
  }
  if (showTitle) {
    propStrs.push(`showTitle={${JSON.stringify(showTitle)}}`);
  }
  if (showDescription) {
    propStrs.push(`showDescription={${JSON.stringify(showDescription)}}`);
  }

  return `<APIPage ${propStrs.join(' ')} />`;
}
