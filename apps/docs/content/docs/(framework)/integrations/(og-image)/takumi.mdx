---
title: Takumi
description: Integrate Takumi for framework agnostic and fast metadata image generation.
---

## Installation

```npm
npm install @takumi-rs/image-response
```

Make sure to add `@takumi-rs/image-response` to `serverExternalPackages` (Next.js) or `external` depends on what bundler you are using.

```ts title="next.config.ts" tab="Next.js"
import type { NextConfig } from 'next';

const config: NextConfig = {
  // [!code ++]
  serverExternalPackages: ['@takumi-rs/image-response'],
};
```

```ts title="vite.config.ts" tab="Nitro / TanStack Start"
import { defineConfig } from 'vite';
// [!code ++]
import takumiPackageJson from '@takumi-rs/core/package.json' with { type: 'json' };

export default defineConfig({
  nitro: {
    externals: {
      // [!code ++:2]
      external: ['@takumi-rs/core'],
      traceInclude: Object.keys(takumiPackageJson.optionalDependencies),
    },
  },
});
```

```ts title="vite.config.ts" tab="Vite"
import { defineConfig } from 'vite';

export default defineConfig({
  ssr: {
    // [!code ++]
    external: ['@takumi-rs/image-response'],
  },
  resolve: {
    alias: {
      // [!code ++:3]
      // If you are using fumadocs-ui/og, you need to alias these packages
      'next/og': import.meta.resolve('@takumi-rs/image-response'),
      'next/dist/compiled/@vercel/og/types': import.meta.resolve('@takumi-rs/image-response'),
    },
  },
});
```

```ts title="waku.config.ts" tab="Waku"
import { defineConfig } from 'waku/config';

export default defineConfig({
  vite: {
    ssr: {
      // [!code ++]
      external: ['@takumi-rs/image-response'],
    },
    resolve: {
      alias: {
        // [!code ++:3]
        // If you are using fumadocs-ui/og, you need to alias these packages
        'next/og': import.meta.resolve('@takumi-rs/image-response'),
        'next/dist/compiled/@vercel/og/types': import.meta.resolve('@takumi-rs/image-response'),
      },
    },
  },
});
```

## Metadata Image

You can generate metadata images dynamically using `@takumi-rs/image-response`.

Add the following under your loader, and define image metadata for pages:

```ts tab="Next.js" title="lib/source.ts"
import { type InferPageType } from 'fumadocs-core/source';

// [!code ++:8]
export function getPageImage(page: InferPageType<typeof source>) {
  const segments = [...page.slugs, 'image.webp'];

  return {
    segments,
    url: `/og/docs/${segments.join('/')}`,
  };
}
```

```tsx tab="Next.js" title="app/docs/[[...slug]]/page.tsx"
import { notFound } from 'next/navigation';
import { source, getPageImage } from '@/lib/source';
import type { Metadata } from 'next';

export async function generateMetadata(props: PageProps<'/docs/[[...slug]]'>): Promise<Metadata> {
  const params = await props.params;
  const page = source.getPage(params.slug);
  if (!page) notFound();

  return {
    title: page.data.title,
    description: page.data.description,
    openGraph: {
      // [!code ++]
      images: getPageImage(page).url,
    },
  };
}
```

```tsx tab="Vite Based Framework" title="app/lib/og.ts"
export function getPageImage(slugs: string[]) {
  const segments = [...slugs, 'image.webp'];

  return {
    segments,
    url: `/og/docs/${segments.join('/')}`,
  };
}
```

```tsx tab="Vite Based Framework" title="app/routes/docs.tsx"
// [!code ++]
import { getPageImage } from '@/lib/og';

// Somewhere in your component or client loader
return (
  <>
    {/* [!code ++] */}
    <meta property="og:image" content={getPageImage(page.slugs).url} />
  </>
);
```

> We append `image.webp` to the end of slugs so that we can access it via `/og/docs/my-page/image.webp`, which results in smaller image sizes. You could use `image.png` if you prefer.

Finally, create a route handler to generate images at build time:

```tsx tab="Next.js" title="app/og/docs/[...slug]/route.tsx"
import { getPageImage, source } from '@/lib/source';
import { notFound } from 'next/navigation';
import { ImageResponse } from '@takumi-rs/image-response';
import { generate as DefaultImage } from 'fumadocs-ui/og';

export const revalidate = false;

export async function GET(_req: Request, { params }: RouteContext<'/og/docs/[...slug]'>) {
  const { slug } = await params;
  const page = source.getPage(slug.slice(0, -1));
  if (!page) notFound();

  return new ImageResponse(
    <DefaultImage title={page.data.title} description={page.data.description} site="My App" />,
    {
      width: 1200,
      height: 630,
      format: 'webp',
    },
  );
}

export function generateStaticParams() {
  return source.getPages().map((page) => ({
    lang: page.locale,
    slug: getPageImage(page).segments,
  }));
}
```

```tsx tab="React Router" title="app/routes/og.tsx"
import { ImageResponse } from '@takumi-rs/image-response';
import { source } from '@/lib/source';
import { generate as DefaultImage } from 'fumadocs-ui/og';
import type { Route } from './+types/og';

export function loader({ params }: Route.LoaderArgs) {
  const slugs = params['*']
    .split('/')
    .filter((v) => v.length > 0)
    .slice(0, -1);
  const page = source.getPage(slugs);

  if (!page) throw new Response(undefined, { status: 404 });

  return new ImageResponse(
    <DefaultImage title={page.data.title} description={page.data.description} site="My App" />,
    {
      width: 1200,
      height: 630,
      format: 'webp',
    },
  );
}
```

```tsx tab="Waku" title="src/pages/_api/og/docs/[...slugs]/image.webp.tsx"
import { source } from '@/lib/source';
import { ImageResponse } from '@takumi-rs/image-response';
import { generate as DefaultImage } from 'fumadocs-ui/og';
import { ApiContext } from 'waku/router';

export async function GET(_: Request, { params }: ApiContext<'/og/docs/[...slugs]/image.webp'>) {
  const page = source.getPage(params.slugs);

  if (!page) throw new Error('Page not found');

  return new ImageResponse(
    <DefaultImage title={page.data.title} description={page.data.description} site="My App" />,
    {
      width: 1200,
      height: 630,
      format: 'webp',
    },
  );
}

export async function getConfig() {
  const pages = source
    .generateParams()
    .map((item) => (item.lang ? [item.lang, ...item.slug] : item.slug));

  return {
    render: 'static' as const,
    staticPaths: pages,
  } as const;
}
```

```ts tab="React Router" title="app/routes.ts"
import { type RouteConfig, route } from '@react-router/dev/routes';

export default [
  // [!code ++]
  route('/og/docs/*', 'routes/og.tsx'),
] satisfies RouteConfig;
```

```ts tab="React Router" title="react-router.config.ts"
import type { Config } from '@react-router/dev/config';
import { glob } from 'node:fs/promises';
import { createGetUrl, getSlugs } from 'fumadocs-core/source';

const getUrl = createGetUrl('/docs');

export default {
  ssr: true,
  future: {
    v8_middleware: true,
  },
  // [!code ++:12]
  async prerender({ getStaticPaths }) {
    const paths = [...getStaticPaths()];

    for await (const entry of glob('**/*.mdx', { cwd: 'content/docs' })) {
      const slugs = getSlugs(entry);

      paths.push(getUrl(slugs));
      paths.push(`/og/docs/${[...slugs, 'image.webp'].join('/')}`);
    }

    return paths;
  },
} satisfies Config;
```

> Takumi comes with pre-bundled full-axis (100-900) [`Geist`](https://vercel.com/font) and `Geist Mono` fonts, so you don't need to worry about it.

See [Takumi's Documentation](https://takumi.kane.tw/docs) for more details or advanced usage.

### Other Templates

There's other available templates, see [Takumi Templates](https://takumi.kane.tw/docs/templates) for a full list.
